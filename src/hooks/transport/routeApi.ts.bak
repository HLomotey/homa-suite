import { supabase } from "@/integration/supabase";
import {
  DatabaseRoute,
  DatabaseRouteSchedule,
  DatabaseCombinedRoute,
  DatabaseCombinedRouteDetail,
  DatabaseRouteAssignment,
  DatabaseRouteExecutionLog,
  FrontendRoute,
  FrontendCombinedRoute,
  FrontendRouteAssignment,
  FrontendRouteExecutionLog,
  mapDatabaseRouteToFrontend,
  mapDatabaseRouteScheduleToFrontend,
  mapDatabaseCombinedRouteToFrontend,
  mapDatabaseRouteAssignmentToFrontend,
  mapDatabaseRouteExecutionLogToFrontend
} from "@/integration/supabase/types/transport-route";

// Utility function to validate date format (YYYY-MM-DD)
function isValidDateFormat(dateString: string): boolean {
  if (!dateString) return false;
  
  // Check format using regex (YYYY-MM-DD)
  const dateFormatRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateFormatRegex.test(dateString)) return false;
  
  // Validate as actual date
  const date = new Date(dateString);
  return !isNaN(date.getTime());
}

// Utility function to validate time format (HH:MM)
function isValidTimeFormat(timeString: string): boolean {
  if (!timeString) return false;
  
  // Check format using regex (HH:MM)
  const timeFormatRegex = /^([01]\d|2[0-3]):([0-5]\d)$/;
  return timeFormatRegex.test(timeString);
}

// Basic Routes API
export async function fetchRoutes(): Promise<FrontendRoute[]> {
  try {
    const { data: routes, error } = await supabase
      .from('routes')
      .select('*')
      .order('name');

    if (error) throw error;

    const { data: schedules, error: schedulesError } = await supabase
      .from('route_schedules')
      .select('*');

    if (schedulesError) throw schedulesError;

    return (routes as DatabaseRoute[]).map(route => {
      const routeSchedules = (schedules as DatabaseRouteSchedule[])
        .filter(schedule => schedule.route_id === route.id);
      return mapDatabaseRouteToFrontend(route, routeSchedules);
    });
  } catch (error) {
    console.error('Error fetching routes:', error);
    throw error;
  }
}

export async function fetchRouteById(id: string): Promise<FrontendRoute> {
  try {
    const { data: route, error } = await supabase
      .from('routes')
      .select('*')
      .eq('id', id)
      .single();

    if (error) throw error;

    const { data: schedules, error: schedulesError } = await supabase
      .from('route_schedules')
      .select('*')
      .eq('route_id', id);

    if (schedulesError) throw schedulesError;

    return mapDatabaseRouteToFrontend(
      route as DatabaseRoute,
      schedules as DatabaseRouteSchedule[]
    );
  } catch (error) {
    console.error(`Error fetching route with id ${id}:`, error);
    throw error;
  }
}

export async function createRoute(
  name: string,
  description: string,
  schedules: { day: string; startTime: string; endTime: string }[]
): Promise<FrontendRoute> {
  try {
    // Insert the route
    const { data: newRoute, error } = await supabase
      .from('routes')
      .insert([{ name, description }])
      .select()
      .single();

    if (error) throw error;

    // Insert the schedules
    const schedulesToInsert = schedules.map(schedule => ({
      route_id: newRoute.id,
      day: schedule.day,
      start_time: schedule.startTime,
      end_time: schedule.endTime
    }));

    const { data: newSchedules, error: schedulesError } = await supabase
      .from('route_schedules')
      .insert(schedulesToInsert)
      .select();

    if (schedulesError) throw schedulesError;

    return mapDatabaseRouteToFrontend(
      newRoute as DatabaseRoute,
      newSchedules as DatabaseRouteSchedule[]
    );
  } catch (error) {
    console.error('Error creating route:', error);
    throw error;
  }
}

export async function updateRoute(
  id: string,
  name: string,
  description: string,
  schedules: { id?: string; day: string; startTime: string; endTime: string }[]
): Promise<FrontendRoute> {
  try {
    // Update the route
    const { data: updatedRoute, error } = await supabase
      .from('routes')
      .update({ name, description })
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;

    // Get existing schedules
    const { data: existingSchedules, error: fetchError } = await supabase
      .from('route_schedules')
      .select('*')
      .eq('route_id', id);

    if (fetchError) throw fetchError;

    // Delete existing schedules
    if (existingSchedules.length > 0) {
      const { error: deleteError } = await supabase
        .from('route_schedules')
        .delete()
        .eq('route_id', id);

      if (deleteError) throw deleteError;
    }

    // Insert new schedules
    const schedulesToInsert = schedules.map(schedule => ({
      route_id: id,
      day: schedule.day,
      start_time: schedule.startTime,
      end_time: schedule.endTime
    }));

    const { data: newSchedules, error: insertError } = await supabase
      .from('route_schedules')
      .insert(schedulesToInsert)
      .select();

    if (insertError) throw insertError;

    return mapDatabaseRouteToFrontend(
      updatedRoute as DatabaseRoute,
      newSchedules as DatabaseRouteSchedule[]
    );
  } catch (error) {
    console.error(`Error updating route with id ${id}:`, error);
    throw error;
  }
}

export async function deleteRoute(id: string): Promise<void> {
  try {
    // Delete schedules first (foreign key constraint)
    const { error: schedulesError } = await supabase
      .from('route_schedules')
      .delete()
      .eq('route_id', id);

    if (schedulesError) throw schedulesError;

    // Delete route
    const { error } = await supabase
      .from('routes')
      .delete()
      .eq('id', id);

    if (error) throw error;
  } catch (error) {
    console.error(`Error deleting route with id ${id}:`, error);
    throw error;
  }
}

// Combined Routes API
export async function fetchCombinedRoutes(): Promise<FrontendCombinedRoute[]> {
  try {
    const { data: combinedRoutes, error } = await supabase
      .from('combined_routes')
      .select('*')
      .order('name');

    if (error) throw error;

    // Fetch all route details with route names
    const { data: details, error: detailsError } = await supabase
      .from('combined_route_details')
      .select(`
        *,
        route_name:routes(name)
      `)
      .order('order');

    if (detailsError) throw detailsError;

    // Transform the data
    return (combinedRoutes as DatabaseCombinedRoute[]).map(combinedRoute => {
      const routeDetails = details.filter(
        detail => detail.combined_route_id === combinedRoute.id
      );
      
      return mapDatabaseCombinedRouteToFrontend(
        combinedRoute,
        routeDetails.map(detail => ({
          ...detail,
          route_name: detail.route_name.name
        }))
      );
    });
  } catch (error) {
    console.error('Error fetching combined routes:', error);
    throw error;
  }
}

export async function fetchCombinedRouteById(id: string): Promise<FrontendCombinedRoute> {
  try {
    const { data: combinedRoute, error } = await supabase
      .from('combined_routes')
      .select('*')
      .eq('id', id)
      .single();

    if (error) throw error;

    // Fetch route details with route names
    const { data: details, error: detailsError } = await supabase
      .from('combined_route_details')
      .select(`
        *,
        route_name:routes(name)
      `)
      .eq('combined_route_id', id)
      .order('order');

    if (detailsError) throw detailsError;

    return mapDatabaseCombinedRouteToFrontend(
      combinedRoute as DatabaseCombinedRoute,
      details.map(detail => ({
        ...detail,
        route_name: detail.route_name.name
      }))
    );
  } catch (error) {
    console.error(`Error fetching combined route with id ${id}:`, error);
    throw error;
  }
}

export async function createCombinedRoute(
  name: string,
  description: string,
  createdBy: string,
  routes: { routeId: string; order: number }[]
): Promise<FrontendCombinedRoute> {
  try {
    // Insert the combined route
    const { data: newCombinedRoute, error } = await supabase
      .from('combined_routes')
      .insert([{ 
        name, 
        description, 
        created_by: createdBy,
        status: 'active'
      }])
      .select()
      .single();

    if (error) throw error;

    // Insert the route details
    const detailsToInsert = routes.map(route => ({
      combined_route_id: newCombinedRoute.id,
      route_id: route.routeId,
      order: route.order
    }));

    const { data: newDetails, error: detailsError } = await supabase
      .from('combined_route_details')
      .insert(detailsToInsert)
      .select();

    if (detailsError) throw detailsError;

    // Fetch route names for the details
    const routeIds = routes.map(route => route.routeId);
    const { data: routeNames, error: namesError } = await supabase
      .from('routes')
      .select('id, name')
      .in('id', routeIds);

    if (namesError) throw namesError;

    // Map route names to details
    const detailsWithNames = newDetails.map(detail => {
      const route = routeNames.find(r => r.id === detail.route_id);
      return {
        ...detail,
        route_name: route ? route.name : 'Unknown Route'
      };
    });

    return mapDatabaseCombinedRouteToFrontend(
      newCombinedRoute as DatabaseCombinedRoute,
      detailsWithNames
    );
  } catch (error) {
    console.error('Error creating combined route:', error);
    throw error;
  }
}

export async function updateCombinedRoute(
  id: string,
  name: string,
  description: string,
  status: 'active' | 'inactive',
  routes: { routeId: string; order: number }[]
): Promise<FrontendCombinedRoute> {
  try {
    // Update the combined route
    const { data: updatedCombinedRoute, error } = await supabase
      .from('combined_routes')
      .update({ name, description, status })
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;

    // Delete existing route details
    const { error: deleteError } = await supabase
      .from('combined_route_details')
      .delete()
      .eq('combined_route_id', id);

    if (deleteError) throw deleteError;

    // Insert new route details
    const detailsToInsert = routes.map(route => ({
      combined_route_id: id,
      route_id: route.routeId,
      order: route.order
    }));

    const { data: newDetails, error: detailsError } = await supabase
      .from('combined_route_details')
      .insert(detailsToInsert)
      .select();

    if (detailsError) throw detailsError;

    // Fetch route names for the details
    const routeIds = routes.map(route => route.routeId);
    const { data: routeNames, error: namesError } = await supabase
      .from('routes')
      .select('id, name')
      .in('id', routeIds);

    if (namesError) throw namesError;

    // Map route names to details
    const detailsWithNames = newDetails.map(detail => {
      const route = routeNames.find(r => r.id === detail.route_id);
      return {
        ...detail,
        route_name: route ? route.name : 'Unknown Route'
      };
    });

    return mapDatabaseCombinedRouteToFrontend(
      updatedCombinedRoute as DatabaseCombinedRoute,
      detailsWithNames
    );
  } catch (error) {
    console.error(`Error updating combined route with id ${id}:`, error);
    throw error;
  }
}

export async function deleteCombinedRoute(id: string): Promise<void> {
  try {
    // Delete route details first (foreign key constraint)
    const { error: detailsError } = await supabase
      .from('combined_route_details')
      .delete()
      .eq('combined_route_id', id);

    if (detailsError) throw detailsError;

    // Delete combined route
    const { error } = await supabase
      .from('combined_routes')
      .delete()
      .eq('id', id);

    if (error) throw error;
  } catch (error) {
    console.error(`Error deleting combined route with id ${id}:`, error);
    throw error;
  }
}

// Route Assignments API
export async function fetchRouteAssignments(): Promise<FrontendRouteAssignment[]> {
  try {
    const { data: assignments, error } = await supabase
      .from('route_assignments')
      .select(`
        *,
        combined_route:combined_routes(name),
        vehicle:vehicles(make, model, license_plate)
      `)
      .order('start_date', { ascending: false });

    if (error) throw error;

    return assignments.map(assignment => mapDatabaseRouteAssignmentToFrontend({
      ...assignment,
      combined_route_name: assignment.combined_route ? assignment.combined_route.name : 'Unknown Route',
      vehicle_info: assignment.vehicle ? 
        `${assignment.vehicle.make} ${assignment.vehicle.model} (${assignment.vehicle.license_plate})` : 
        'Unknown Vehicle',
      driver_name: `Driver ID: ${assignment.driver_id}`
    }));
  } catch (error) {
    console.error('Error fetching route assignments:', error);
    throw error;
  }
}

export async function fetchRouteAssignmentById(id: string): Promise<FrontendRouteAssignment> {
  try {
    const { data: assignment, error } = await supabase
      .from('route_assignments')
      .select(`
        *,
        combined_route:combined_routes(name),
        vehicle:vehicles(make, model, license_plate),
        
      `)
      .eq('id', id)
      .single();

    if (error) throw error;

    // Fetch execution logs
    const { data: logs, error: logsError } = await supabase
      .from('route_execution_logs')
      .select('*')
      .eq('route_assignment_id', id)
      .order('execution_date', { ascending: false });

    if (logsError) throw logsError;

    const result = mapDatabaseRouteAssignmentToFrontend({
      ...assignment,
      combined_route_name: assignment.combined_route ? assignment.combined_route.name : 'Unknown Route',
      vehicle_info: assignment.vehicle ? 
        `${assignment.vehicle.make} ${assignment.vehicle.model} (${assignment.vehicle.license_plate})` : 
        'Unknown Vehicle',
      driver_name: `Driver ID: ${assignment.driver_id}`
    });

    result.executionLogs = logs.map(log => 
      mapDatabaseRouteExecutionLogToFrontend(log as DatabaseRouteExecutionLog)
    );

    return result;
  } catch (error) {
    console.error(`Error fetching route assignment with id ${id}:`, error);
    throw error;
  }
}

export async function createRouteAssignment(
  combinedRouteId: string,
  vehicleId: string,
  driverId: string,
  startDate: string,
  endDate: string | null,
  notes: string
): Promise<FrontendRouteAssignment> {
  try {
    // Debug logging for date fields
    console.log('Creating route assignment with date fields:', { startDate, endDate });
    
    // Validate date formats
    if (startDate && !isValidDateFormat(startDate)) {
      throw new Error(`Invalid start date format: ${startDate}. Expected format: YYYY-MM-DD`);
    }
    
    if (endDate && !isValidDateFormat(endDate)) {
      throw new Error(`Invalid end date format: ${endDate}. Expected format: YYYY-MM-DD`);
    }
    const { data: newAssignment, error } = await supabase
      .from('route_assignments')
      .insert([{
        combined_route_id: combinedRouteId,
        vehicle_id: vehicleId,
        driver_id: driverId,
        start_date: startDate,
        end_date: endDate,
        status: 'scheduled',
        notes
      }])
      .select(`
        *,
        combined_route:combined_routes(name),
        vehicle:vehicles(make, model, license_plate),
        
      `)
      .single();

    if (error) throw error;

    return mapDatabaseRouteAssignmentToFrontend({
      ...newAssignment,
      combined_route_name: newAssignment.combined_route ? newAssignment.combined_route.name : 'Unknown Route',
      vehicle_info: newAssignment.vehicle ? 
        `${newAssignment.vehicle.make} ${newAssignment.vehicle.model} (${newAssignment.vehicle.license_plate})` : 
        'Unknown Vehicle',
      driver_name: newAssignment.driver ? 
        `${newAssignment.driver.first_name} ${newAssignment.driver.last_name}` : 
        'Unknown Driver'
    });
  } catch (error) {
    console.error('Error creating route assignment:', error);
    throw error;
  }
}

export async function updateRouteAssignment(
  id: string,
  vehicleId: string,
  driverId: string,
  startDate: string,
  endDate: string | null,
  status: 'scheduled' | 'in_progress' | 'completed' | 'cancelled',
  notes: string
): Promise<FrontendRouteAssignment> {
  try {
    // Debug logging for date fields
    console.log('Updating route assignment with date fields:', { id, startDate, endDate });
    
    // Validate date formats
    if (startDate && !isValidDateFormat(startDate)) {
      throw new Error(`Invalid start date format: ${startDate}. Expected format: YYYY-MM-DD`);
    }
    
    if (endDate && !isValidDateFormat(endDate)) {
      throw new Error(`Invalid end date format: ${endDate}. Expected format: YYYY-MM-DD`);
    }
    const { data: updatedAssignment, error } = await supabase
      .from('route_assignments')
      .update({
        vehicle_id: vehicleId,
        driver_id: driverId,
        start_date: startDate,
        end_date: endDate,
        status,
        notes
      })
      .eq('id', id)
      .select(`
        *,
        combined_route:combined_routes(name),
        vehicle:vehicles(make, model, license_plate),
        
      `)
      .single();

    if (error) throw error;

    return mapDatabaseRouteAssignmentToFrontend({
      ...updatedAssignment,
      combined_route_name: updatedAssignment.combined_route ? updatedAssignment.combined_route.name : 'Unknown Route',
      vehicle_info: updatedAssignment.vehicle ? 
        `${updatedAssignment.vehicle.make} ${updatedAssignment.vehicle.model} (${updatedAssignment.vehicle.license_plate})` : 
        'Unknown Vehicle',
      driver_name: updatedAssignment.driver ? 
        `${updatedAssignment.driver.first_name} ${updatedAssignment.driver.last_name}` : 
        'Unknown Driver'
    });
  } catch (error) {
    console.error(`Error updating route assignment with id ${id}:`, error);
    throw error;
  }
}

export async function deleteRouteAssignment(id: string): Promise<void> {
  try {
    // Delete execution logs first (foreign key constraint)
    const { error: logsError } = await supabase
      .from('route_execution_logs')
      .delete()
      .eq('route_assignment_id', id);

    if (logsError) throw logsError;

    // Delete assignment
    const { error } = await supabase
      .from('route_assignments')
      .delete()
      .eq('id', id);

    if (error) throw error;
  } catch (error) {
    console.error(`Error deleting route assignment with id ${id}:`, error);
    throw error;
  }
}

// Route Execution Logs API
export async function createRouteExecutionLog(
  routeAssignmentId: string,
  executionDate: string,
  startTime: string,
  status: 'started' | 'completed' | 'delayed' | 'cancelled',
  notes: string,
  delayReason?: string,
  endTime?: string
): Promise<FrontendRouteExecutionLog> {
  try {
    // Debug logging for date fields
    console.log('Creating route execution log with date fields:', { executionDate, startTime, endTime });
    
    // Validate date format
    if (executionDate && !isValidDateFormat(executionDate)) {
      throw new Error(`Invalid execution date format: ${executionDate}. Expected format: YYYY-MM-DD`);
    }
    
    // Validate time format (HH:MM)
    if (startTime && !isValidTimeFormat(startTime)) {
      throw new Error(`Invalid start time format: ${startTime}. Expected format: HH:MM`);
    }
    
    if (endTime && !isValidTimeFormat(endTime)) {
      throw new Error(`Invalid end time format: ${endTime}. Expected format: HH:MM`);
    }
    const { data: newLog, error } = await supabase
      .from('route_execution_logs')
      .insert([{
        route_assignment_id: routeAssignmentId,
        execution_date: executionDate,
        start_time: startTime,
        end_time: endTime,
        status,
        delay_reason: delayReason,
        notes
      }])
      .select()
      .single();

    if (error) throw error;

    return mapDatabaseRouteExecutionLogToFrontend(newLog as DatabaseRouteExecutionLog);
  } catch (error) {
    console.error('Error creating route execution log:', error);
    throw error;
  }
}

export async function updateRouteExecutionLog(
  id: string,
  endTime: string,
  status: 'completed' | 'delayed' | 'cancelled',
  notes: string,
  delayReason?: string
): Promise<FrontendRouteExecutionLog> {
  try {
    const { data: updatedLog, error } = await supabase
      .from('route_execution_logs')
      .update({
        end_time: endTime,
        status,
        delay_reason: delayReason,
        notes
      })
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;

    return mapDatabaseRouteExecutionLogToFrontend(updatedLog as DatabaseRouteExecutionLog);
  } catch (error) {
    console.error(`Error updating route execution log with id ${id}:`, error);
    throw error;
  }
}

export async function fetchRouteExecutionLogsByAssignment(
  assignmentId: string
): Promise<FrontendRouteExecutionLog[]> {
  try {
    const { data: logs, error } = await supabase
      .from('route_execution_logs')
      .select('*')
      .eq('route_assignment_id', assignmentId)
      .order('execution_date', { ascending: false });

    if (error) throw error;

    return (logs as DatabaseRouteExecutionLog[]).map(log => 
      mapDatabaseRouteExecutionLogToFrontend(log)
    );
  } catch (error) {
    console.error('Error fetching route execution logs:', error);
    throw error;
  }
}

export async function deleteRouteExecutionLog(id: string): Promise<void> {
  try {
    const { error } = await supabase
      .from('route_execution_logs')
      .delete()
      .eq('id', id);

    if (error) throw error;
  } catch (error) {
    console.error('Error deleting route execution log:', error);
    throw error;
  }
}
